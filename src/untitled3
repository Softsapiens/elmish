###
app.init     : () -> state
app.update   : (state, action) -> state
app.view     : (dispatch, state, data) -> html
app.effect   : (state) -> tree

http.init    : () -> state
http:update  : (respond) -> (state, action) -> state
http:data    : (state) -> data

debug.init   : () -> state
debug.update : (state, action) -> state
debug.view   : (dispatch, state) -> state


debug state = {app, http}

###

act = (type) -> (action) -> {type, action}

start = (app, http, debug) ->
  action$ = flyd.stream()



  state$ = flyd.scan(debug.update, debug.init, action$)


  effect$ = flyd.map(effect, state$)

  app.init()

update = (state, action) ->
  switch action.type
    when 'play'
      R.assoc('paused', false, state)
    when 'pause'
      R.assoc('paused', true, state)
    when 'change_time'
      R.evolve({time, R.inc}, state)
    when 'child_action'
      if state.paused
        state

      else
        # nextState = app.update(state.list[state.time].state, action.action)
        # R.evolve(
        #   list: R.pipe(
        #     R.take(state.time)
        #     R.append(next)
        #   )
        #   time: R.inc
        # )(state)
    else
      state



start = ->
  action$ = flyd.stream()
  state$ = flyd.scan(update, init(), action$)
  effect$ = flyd.map(effect, state$)
  # handleEffect gets the effect output and returns a data
  # stream that gets piped back to the views
  data$ = handleEffect(effect$)
  html$ = flyd.lift(
    (state, data) -> view(action$, state, data)
    state$, data$
  )
  flyd.on(render, html$)
  # monitor?({action$, state$, effect$, data$, html$})

