###
debug inputs:
- actions:
  - time changed
  - pause play
  - app 

###

make = (app) ->

  init = ->
    {time: 0, list:[app.init()], paused: false}


  # debug
  # - gets 

  update = (state, action) ->
    switch action.type
      when 'play'
        R.assoc('paused', false, state)
      when 'pause'
        R.assoc('paused', true, state)
      when 'change_time'
        R.evolve({time, R.inc}, state)
      when 'child_action'
        if state.paused
          state
        else
          nextState = app.update(state.list[state.time].state, action.action)
          R.evolve(
            list: R.pipe(
              R.take(state.time)
              R.append(next)
            )
            time: R.inc
          )(state)
      else
        state

  effect = ()




start = (app, handleEffect) ->


  debug.action$ = flyd.stream() # pause/play, set time

  # app.action$ = flyd.stream()
  # app.state$ = flyd.scan(app.update, app.init(), app.action$)
  # app.effect$ = flyd.map(app.effect, app.state$)
  


  # handleEffect gets the effect output and returns a data
  # stream that gets piped back to the views
  app.data$ = handleEffect(app.effect$)

  debug.state$ = flyd.scan(
    debug.update
    debug.init(app.init())
    debug.action$
  )


  # this is the app state
  app$ = flyd.lift(
    (state, data) -> {state, data}
    state$, data$
  )

  # pipe the app state to debug as a new state
  # block actions if paused
  # 




  appAction$ = flyd.map(
    ({state, data}) -> {type:'app', state, data}
    app$
  )

  flyd.merge(debug.action$, appAction$)

  debug.view(childView, dispatchDebug, dispatchApp, state)




  # debug view picks the right 


  both$ = flyd.lift(
    (state, data) -> {state, data}
    state$, data$
  )




  flyd.map(debug.update, time$)


  html$ = flyd.lift(
    (state, data) -> view(action$, state, data)
    state$, data$
  )
  flyd.on(render, html$)
  # monitor?({action$, state$, effect$, data$, html$})


